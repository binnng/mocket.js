(function (window, document, undefined) {
    if (!Array.prototype.forEach) {
        Array.prototype.forEach = function (fn, scope) {
            for (var i = 0, len = this.length; i < len; ++i) {
                if (i in this) {
                    fn.call(scope, this[i], i, this);
                }
            }
        };
    }
    /**
* 对本地存贮对象的操作封装
*/
    var localStorageName = 'localStorage';
    function isLocalStorageSupported() {
        try {
            var supported = localStorageName in window && window[localStorageName];
            var name = '__store';
            if (supported) {
                localStorage.setItem(name, '');
                localStorage.removeItem(name);
                return supported;
            }
        } catch (err) {
            return false;
        }
    }
    var Store = function (key, value) {
        var storage = Store.get();
        if (storage) {
            if ('undefined' === typeof value) {
                return storage.getItem(key);
            } else {
                storage.setItem(key, value);
            }
        }
    };
    Store.isSupport = isLocalStorageSupported();
    Store.get = function () {
        if (Store.isSupport) {
            var _localStorage = window[localStorageName];
            Store.get = function () {
                return _localStorage;
            };
            return _localStorage;
        } else {
            return false;
        }
    };
    /**
 * 清除本地存贮数据
 * @param {String} prefix 可选，如果包含此参数，则只删除包含此前缀的项，否则清除全部缓存
 */
    Store.clear = function (prefix) {
        var storage = Store.get();
        if (storage) {
            if (prefix) {
                for (var key in storage) {
                    if (0 === key.indexOf(prefix)) {
                        storage.removeItem(key);
                    }
                }
            } else {
                storage.clear();
            }
        }
    };
    window.Store = Store;
    /*global console*/
    //
    // loadScript.js defines loadScript(), a global function for performing asynchronous
    // script loads.
    //
    // https://github.com/zynga/loadScript
    // Author: Chris Campbell (@quaelin)
    // License: BSD
    //
    (function (win, doc, undef) {
        'use script';
        var loadScript, funcName = 'loadScript', VERSION = '0.1.5', had = Object.prototype.hasOwnProperty.call(win, funcName), previous = win[funcName], loading = {}, loaded = {};
        function log(msg) {
            if (typeof console !== 'undefined' && console && console.log) {
                console.log(msg);
            }
        }
        // Perform text substitutions on `origURL` according to the substitution
        // rules stored in localStorage `key` (if present).  This is a developer
        // feature; to use it, you must name the localStorage key by setting it like
        // this:
        //
        //   loadScript.key = 'loader_rules';
        //
        // Then you can set the corresponding value in localStorage to a JSON-ified
        // array of arrays, where each inner array is a pair of the form:
        //
        //   [searchtext, replacetext]
        //
        // This allows the developer to load, for instance, a newer or unminified
        // version of a particular script.
        function rewrite(origURL) {
            var substitutions = [], key = loadScript.key;
            if (key) {
                try {
                    substitutions = JSON.parse(localStorage.getItem(key)) || [];
                } catch (ex) {
                }
            }
            var i = -1, len = substitutions.length, rule, url = origURL;
            while (++i < len) {
                rule = substitutions[i];
                url = url.replace(rule[0], rule[1]);
            }
            if (url !== origURL) {
                log(funcName + ': rewrite("' + origURL + '")');
                log(' => "' + url + '"');
            }
            return url;
        }
        // Here is the loadScript() function itself.
        loadScript = win[funcName] = function (requestURL, callback) {
            var el,
                // url = rewrite(requestURL),
                url = requestURL, needToLoad = !loading[url], q = loading[url] = loading[url] || [];
            function doCallback() {
                if (callback) {
                    callback();
                }
            }
            if (loaded[url]) {
                doCallback();
                return;
            }
            q.push(doCallback);
            function onLoad() {
                loaded[url] = 1;
                while (q.length) {
                    q.shift()();
                }
            }
            if (needToLoad) {
                el = doc.createElement('script');
                el.type = 'text/javascript';
                if (el.addEventListener) {
                    el.addEventListener('load', onLoad, false);
                } else {
                    // IE
                    el.attachEvent('onreadystatechange', onLoad);
                }
                // if (url !== requestURL) {
                if (false) {
                    el.setAttribute('data-requested', requestURL);
                }
                el.src = url;
                doc.getElementsByTagName('head')[0].appendChild(el);
            }
        };
    }(this, document));
    var groupArray = function (arr, num, fill) {
        // arr = [] || num = 0
        if (!arr.length || !num)
            return arr;
        // 返回的数组
        var arr_back = [];
        // 数组的任一元素
        var item;
        // 数组的任一分组
        var column = [];
        function next(i) {
            if ((item = arr[i]) === undefined)
                return;
            column.push(item);
            // 最后一个元素
            if (i == arr.length - 1) {
                // 用空串填满数组
                if (fill)
                    while (column.length < num)
                        column.push({ pass: true });
                arr_back.push(column);
                return;
            }
            // 完成一个分组
            if (column.length == num) {
                arr_back.push(column);
                column = [];
            }
            next(++i);
        }
        next(0);
        return arr_back;
    };
    var require, define;
    (function (window) {
        var head = document.getElementsByTagName('head')[0];
        var loadingMap = {};
        var factoryMap = {};
        var modulesMap = {};
        var resMap;
        var pkgMap;
        var isStorageSupport = Store.isSupport;
        var comboSyntax = [
            '??',
            ','
        ];
        var comboServe = '/combo';
        var storePrefix = 'mocket-';
        var search = location.search || '';
        // 最大combo资源数，默认10个
        var maxComboNum = 10;
        // 屏蔽读取storage，便于开发
        // 1) window.ignoreStore = true
        // 2) URL中有ignoreStore
        var ignoreStore = window.ignoreStore || search.match(/ignoreStore/);
        var isClearStore = search.match(/clearStore/);
        // 执行代码片段
        function exec(s) {
            new Function(s)();
        }
        // 获取存储的模块集合
        function getStores() {
            var stores = {};
            var storage = Store.get();
            for (var key in storage) {
                if (0 === key.indexOf(storePrefix)) {
                    stores[key.substr(storePrefix.length)] = storage[key];
                }
            }
            return stores;
        }
        // 拼接combo的url
        function getComboURI(requires) {
            var start = comboSyntax[0];
            // ??
            var sep = comboSyntax[1];
            // ,
            return comboServe + start + requires.join(sep);
        }
        // 将执行中的define函数，以字符串形式输出存储
        function stringify(id, factory) {
            return 'define(\'' + id + '\',' + factory.toString() + ');';
        }
        ;
        // 通过静态资源id从resMap中获取实际url
        function getStaticURI(id) {
            var res = (resMap || {})[id] || {};
            var url;
            var pkgID = res['pkg'];
            if (pkgID) {
                url = pkgMap[pkgID]['url'];
            } else {
                url = res['url'] || id;
            }
            return url;
        }
        ;
        function clearStore() {
            Store.clear(storePrefix);
        }
        ;
        define = function (id, factory) {
            factoryMap[id] = factory;
            var queue = loadingMap[id];
            if (queue) {
                for (var i = queue.length - 1; i >= 0; --i) {
                    queue[i]();
                }
                delete loadingMap[id];
            }
            if (!isClearStore && isStorageSupport) {
                var storeId = storePrefix + getStaticURI(id);
                if (!Store(storeId)) {
                    Store(storeId, stringify(id, factory));
                }
            }
        };
        require = function (id) {
            id = require.alias(id);
            var mod = modulesMap[id];
            if (mod) {
                return mod['exports'];
            }
            //
            // init module
            //
            var factory = factoryMap[id];
            if (!factory) {
                throw Error('Cannot find module `' + id + '`');
            }
            mod = modulesMap[id] = { 'exports': {} };
            //
            // factory: function OR value
            //
            var ret = typeof factory == 'function' ? factory.apply(mod, [
                require,
                mod['exports'],
                mod
            ]) : factory;
            if (ret) {
                mod['exports'] = ret;
            }
            return mod['exports'];
        };
        require.async = function (names, callback) {
            if (typeof names == 'string') {
                names = [names];
            }
            for (var i = names.length - 1; i >= 0; --i) {
                names[i] = require.alias(names[i]);
            }
            var needMap = {};
            var needURLMap = [];
            var stores = getStores();
            var needLoad = [];
            var needNum = 0;
            var hasStored = [];
            findNeed(names);
            updateStore();
            if (hasStored.length) {
                // 保险延迟
                setTimeout(function () {
                    hasStored.forEach(function (i) {
                        exec(stores[i]);
                    });
                }, 0);
            }
            if (needLoad.length) {
                groupNeed();
            } else {
                setTimeout(next, 1);
            }
            function findNeed(depArr) {
                for (var i = depArr.length - 1; i >= 0; --i) {
                    //
                    // skip loading or loaded
                    //
                    var dep = depArr[i];
                    var url = getStaticURI(dep);
                    if (dep in factoryMap || dep in needMap) {
                        continue;
                    }
                    needMap[dep] = true;
                    needURLMap.push(url);
                    var child = resMap[dep];
                    if (child && child.deps) {
                        findNeed(child.deps);
                    }
                }
            }
            function updateStore() {
                needURLMap.forEach(function (item) {
                    if (!ignoreStore && item in stores) {
                        hasStored.push(item);
                    } else {
                        needLoad.push(item);
                    }
                });
            }
            function updateNeed() {
                if (0 == --needNum) {
                    next();
                }
            }
            function groupNeed() {
                var group = groupArray(needLoad, maxComboNum);
                var files;
                for (var i = group.length - 1; i >= 0; --i) {
                    needNum++;
                    files = group[i];
                    loadScript(files.length > 1 ? getComboURI(files) : files[0], updateNeed);
                }
            }
            // 按顺序传递参数执行
            function next() {
                var modules = [];
                names.forEach(function (item) {
                    modules.push(require(item));
                });
                callback.apply(window, modules);
            }
        };
        require.resourceMap = function (obj) {
            resMap = obj['res'] || {};
            pkgMap = obj['pkg'] || {};
        };
        require.alias = function (id) {
            return id;
        };
        require.config = function (data) {
            data.comboSyntax && (comboSyntax = data.comboSyntax);
            data.comboServe && (comboServe = data.comboServe);
            /boolean/i.test(typeof data.ignoreStore) && (ignoreStore = data.ignoreStore);
            data.maxComboNum && (maxComboNum = data.maxComboNum);
        };
        define.amd = {
            'jQuery': true,
            'version': '1.0.0'
        };
        if (isClearStore) {
            clearStore();
        }
        window.require = require;
        window.define = define;
    }(window));
}(window, document));